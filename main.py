# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gshdvIGsNlWUGqIXIoAKGQa9l4LTXChY
"""

!pip install pydantic-ai requests
!npm install -g @mermaid-js/mermaid-cli

import os
import subprocess
import json
import time
import random
from typing import Optional, Tuple
from pathlib import Path
import requests
from pydantic import BaseModel, Field
from pydantic_ai import Agent
import asyncio
import sys

import os
os.environ["GOOGLE_API_KEY"] = "your api key"

class DiagramResponse(BaseModel):
    code: str = Field(..., description="Generated diagram code")
    explanation: str = Field(..., description="Explanation of the generated diagram")
    needs_improvement: bool = Field(default=True, description="Whether the diagram needs improvement")

class DiagramGenerator:
    def __init__(self, api_key: Optional[str] = None, max_iterations: int = 3):
        self.api_key = api_key or "your api key"
        self.max_iterations = max_iterations
        self.output_dir = Path("output")
        self.output_dir.mkdir(exist_ok=True)
        self.agent = Agent(
            'gemini-1.5-flash',
            system_prompt="""You are an expert diagram generator specializing in Mermaid diagrams.
            Always output JSON with: code, explanation, needs_improvement."""
        )

    def _normalize_bool(self, value):
        if isinstance(value, bool):
            return value
        if isinstance(value, str):
            val = value.strip().lower()
            return val in ["true", "yes", "1"]
        return False

    def _sanitize_response(self, parsed: dict) -> dict:
        """Ensure parsed dict has correct types for DiagramResponse"""
        if "code" in parsed:
            parsed["code"] = str(parsed["code"])
        if "explanation" in parsed:
            parsed["explanation"] = str(parsed["explanation"])
        parsed["needs_improvement"] = self._normalize_bool(parsed.get("needs_improvement"))
        return parsed

    def _extract_json(self, text: str) -> dict:
        """Extract first valid JSON object from a string"""
        start = text.find("{")
        end = text.rfind("}") + 1
        if start == -1 or end == -1:
            raise ValueError(f"No JSON found in text: {text[:200]}")
        snippet = text[start:end]
        parsed = json.loads(snippet)
        return self._sanitize_response(parsed)

    def _retry_request(self, func, max_retries=3, base_delay=2):
        for attempt in range(max_retries):
            try:
                return func()
            except requests.exceptions.HTTPError as e:
                if e.response.status_code == 503:
                    wait = base_delay * (2 ** attempt) + random.uniform(0, 1)
                    print(f"503 Service Unavailable. Retrying in {wait:.1f}s...")
                    time.sleep(wait)
                else:
                    raise
        raise Exception("Max retries reached. Service still unavailable.")

    def _call_gemini_api(self, prompt: str) -> dict:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key={self.api_key}"
        headers = {'Content-Type': 'application/json'}
        data = {
            "contents": [{"parts": [{"text": prompt}]}],
            "generationConfig": {"temperature": 0.7, "topK": 40, "topP": 0.95, "maxOutputTokens": 1024}
        }

        def make_request():
            response = requests.post(url, headers=headers, json=data, timeout=30)
            response.raise_for_status()
            return response.json()

        result = self._retry_request(make_request)
        try:
            text = result['candidates'][0]['content']['parts'][0]['text']
        except KeyError:
            raise Exception(f"Unexpected API response format: {json.dumps(result, indent=2)}")
        return self._extract_json(text)

    async def generate_diagram(self, query: str) -> DiagramResponse:
        try:
            result = await self.agent.run(query)
            raw_text = str(result.output).strip()
            parsed = self._extract_json(raw_text)
            return DiagramResponse(**parsed)
        except Exception:
            prompt = f"""Generate a Mermaid diagram for: "{query}".
            Respond in JSON with keys: code, explanation, needs_improvement"""
            parsed = self._call_gemini_api(prompt)
            return DiagramResponse(**parsed)

    def save_diagram(self, code: str, filename: str = "output.mmd") -> Path:
        output_path = self.output_dir / filename
        output_path.write_text(code, encoding='utf-8')
        return output_path

    def render_diagram(self, mermaid_file: Path) -> Tuple[bool, Optional[str], Optional[Path]]:
        output_file = mermaid_file.with_suffix('.png')
        try:
            subprocess.run(['mmdc', '--version'], capture_output=True, check=True)
        except Exception:
            return False, "mermaid-cli not installed", None
        result = subprocess.run(
            ['mmdc', '-i', str(mermaid_file), '-o', str(output_file), '--backgroundColor', 'white'],
            capture_output=True, text=True, timeout=30
        )
        if result.returncode == 0:
            return True, None, output_file
        else:
            error_msg = result.stderr or result.stdout or "Unknown rendering error"
            return False, error_msg, None

    async def refine_diagram(self, current_code: str, feedback: str, is_error: bool = False) -> DiagramResponse:
        if is_error:
            prompt = f"""The following Mermaid code caused an error:
            ```mermaid
            {current_code}
            ```
            Error: {feedback}
            Fix and return JSON: code, explanation, needs_improvement"""
        else:
            prompt = f"""This Mermaid code rendered successfully:
            ```mermaid
            {current_code}
            ```
            Suggest improvements if any. Respond in JSON: code, explanation, needs_improvement"""
        try:
            result = await self.agent.run(prompt)
            raw_text = str(result.output).strip()
            parsed = self._extract_json(raw_text)
            return DiagramResponse(**parsed)
        except Exception:
            parsed = self._call_gemini_api(prompt)
            return DiagramResponse(**parsed)

    async def generate_and_refine(self, query: str) -> None:
        response = await self.generate_diagram(query)
        current_code = response.code
        diagram_file = self.save_diagram(current_code, "output.mmd")

        iteration = 0
        final_file = diagram_file
        while iteration < self.max_iterations:
            iteration += 1
            success, error_message, output_file = self.render_diagram(final_file)
            if not success:
                refined = await self.refine_diagram(current_code, error_message, is_error=True)
                current_code = refined.code
                final_file = self.save_diagram(current_code, f"output_iter_{iteration}.mmd")
            else:
                refined = await self.refine_diagram(current_code, "Rendered OK", is_error=False)
                if not refined.needs_improvement:
                    break
                current_code = refined.code
                final_file = self.save_diagram(current_code, f"output_iter_{iteration}.mmd")

        self.render_diagram(final_file)

def main():
    query = input("Query: ").strip()
    if not query:
        print("Empty query")
        return
    try:
        max_iter_input = input("Maximum refinement iterations (default 3): ").strip()
        max_iterations = int(max_iter_input) if max_iter_input else 3
    except ValueError:
        max_iterations = 3
    generator = DiagramGenerator(max_iterations=max_iterations)

    if "google.colab" in sys.modules:  # Running in Colab
        import nest_asyncio
        nest_asyncio.apply()
        loop = asyncio.get_event_loop()
        loop.run_until_complete(generator.generate_and_refine(query))
    else:  # Local Python
        asyncio.run(generator.generate_and_refine(query))


if __name__ == "__main__":
    main()